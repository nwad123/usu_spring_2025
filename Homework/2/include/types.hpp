#pragma once

#include "fmt/base.h"
#include "fmt/ranges.h"
#include <algorithm>
#include <chrono>
#include <string_view>
#include <vector>

namespace hpc {

using fp = float;

/// Defines the config for the histogram generators.
/// Preconditions:
/// - `threads`, `bins`, and `size` must be `!= 0`
/// - `min < max`
struct Config
{
    size_t threads;
    size_t bins;
    fp min;
    fp max;
    size_t size;

    inline auto print() const -> void;
    constexpr auto operator==(/*in*/ const Config &other) const -> bool = default;
};

/// Defines a histogram bin storing the maxes and counts of a dataset
struct Bin
{
    std::vector<fp> maxes;
    std::vector<size_t> counts;

    inline auto report() const -> void;

    constexpr auto operator==(/*in*/ const Bin &other) const -> bool
    {
        return std::ranges::equal(maxes, other.maxes) && std::ranges::equal(counts, other.counts);
    }

    inline constexpr auto resize(/*in*/ const size_t size) -> void
    {
        maxes.resize(size);
        counts.resize(size);
    }
};

/// `Timer` provides a scoped timer class that starts counting when in scope. The
/// time since the object came into scope can be obtained with the `elapsed_ms()`
/// method.
///
/// Disclaimer: `Timer` class initially generated by claude.ai, but had to be
/// edited by me.
class Timer
{
  private:
    using clock = std::chrono::high_resolution_clock;
    using time_point = clock::time_point;

    time_point start_time;

  public:
    Timer() : start_time(clock::now()) {}

    double elapsed_ms() const
    {
        const auto current = clock::now();
        const auto duration = std::chrono::duration<double, std::milli>(current - start_time);
        return duration.count();
    }

    void reset() { start_time = clock::now(); }
};

/// `Result` return a timing result after calling `SolverTimer.operator()`. The result contains
/// only timing information, no information about the bins are kept.
struct Result
{
    std::string_view name;
    double time_ms;
    double std_dev_ms;
    double min_ms;
    double max_ms;
    Config config;
};

inline auto Config::print() const -> void
{
    fmt::println(
        "\"Config\": {{\n"
        "  \"Threads\": {},\n"
        "  \"Bins\": {},\n"
        "  \"Data range\":  [{}, {}],\n"
        "  \"Data size\":   {}\n"
        "}},",
        threads,
        bins,
        min,
        max,
        size
    );
}

inline auto Bin::report() const -> void
{
    fmt::println("  \"Maxes\":  {},", maxes);
    fmt::println("  \"Counts\": {}", counts);
}
} // namespace hpc
